// Service ƒë·ªÉ x·ª≠ l√Ω ·∫£nh t·ª´ Supabase Storage - Optimized for mobile
import { supabase } from '../lib/supabase';

const supabaseUrl = process.env.REACT_APP_SUPABASE_URL || 'https://oqtlakdvlmkaalymgrwd.supabase.co';

// Cache ƒë·ªÉ tr√°nh request tr√πng l·∫∑p
const imageCache = new Map();
const bucketCache = new Set();

// Mobile-optimized image sizes
const MOBILE_SIZES = {
    avatar: { width: 150, height: 150, quality: 80 },
    thumbnail: { width: 300, height: 200, quality: 75 },
    full: { width: 800, height: 600, quality: 85 }
};

// Ki·ªÉm tra bucket c√≥ t·ªìn t·∫°i kh√¥ng
const checkBucketExists = async (bucketName) => {
    if (bucketCache.has(bucketName)) {
        return true;
    }

    try {
        const { data, error } = await supabase.storage.listBuckets();
        if (!error && data) {
            const bucketExists = data.some(bucket => bucket.name === bucketName);
            if (bucketExists) {
                bucketCache.add(bucketName);
            }
            return bucketExists;
        }
    } catch (err) {
        console.log(`‚ùå Error checking bucket ${bucketName}:`, err.message);
    }

    return false;
};

export const getUserImageSrc = async (imagePath, name = 'User', size = 'avatar') => {
    if (!imagePath) {
        console.log('‚ùå No image path provided, using default');
        return '/images/defaultUser.png';
    }

    // T·∫°o cache key v·ªõi size
    const cacheKey = `${imagePath}_${size}`;

    // Ki·ªÉm tra cache tr∆∞·ªõc
    if (imageCache.has(cacheKey)) {
        return imageCache.get(cacheKey);
    }

    // N·∫øu imagePath ƒë√£ l√† URL ƒë·∫ßy ƒë·ªß, tr·∫£ v·ªÅ lu√¥n
    if (imagePath.startsWith('http')) {
        imageCache.set(cacheKey, imagePath);
        return imagePath;
    }

    // X·ª≠ l√Ω path ƒë·ªÉ tr√°nh duplicate
    let cleanPath = imagePath;
    if (imagePath.startsWith('profiles/')) {
        cleanPath = imagePath.replace('profiles/', '');
    }

    console.log(`üîç Looking for image: ${cleanPath} (size: ${size})`);

    // Th·ª≠ c√°c bucket v√† th∆∞ m·ª•c con
    const searchPaths = [
        { bucket: 'upload', path: `profiles/${cleanPath}` },
        { bucket: 'upload', path: `profile/${cleanPath}` },
        { bucket: 'upload', path: `postImages/${cleanPath}` },
        { bucket: 'upload', path: `postVideo/${cleanPath}` },
        { bucket: 'upload', path: cleanPath },
        { bucket: 'profiles', path: cleanPath },
        { bucket: 'avatars', path: cleanPath }
    ];

    for (const { bucket, path } of searchPaths) {
        try {
            console.log(`üîç Checking bucket: ${bucket}, path: ${path}`);

            // Ki·ªÉm tra bucket c√≥ t·ªìn t·∫°i kh√¥ng tr∆∞·ªõc (skip check cho upload bucket)
            if (bucket !== 'upload') {
                const bucketExists = await checkBucketExists(bucket);
                if (!bucketExists) {
                    console.log(`‚ùå Bucket ${bucket} does not exist, skipping`);
                    continue;
                }
            } else {
                console.log(`‚úÖ Skipping bucket check for upload bucket`);
            }

            // Th·ª≠ t·∫°o signed URL v·ªõi th·ªùi gian d√†i h∆°n
            const signedUrlPromise = supabase.storage
                .from(bucket)
                .createSignedUrl(path, 86400); // 24 gi·ªù

            const timeoutPromise = new Promise((_, reject) =>
                setTimeout(() => reject(new Error('Timeout')), 3000)
            );

            const { data, error } = await Promise.race([signedUrlPromise, timeoutPromise]);

            if (!error && data?.signedUrl) {
                console.log(`‚úÖ Found image in bucket: ${bucket}, path: ${path}`);

                // Optimize URL for mobile if needed
                let optimizedUrl = data.signedUrl;
                if (size !== 'full' && MOBILE_SIZES[size]) {
                    optimizedUrl = addImageOptimization(data.signedUrl, MOBILE_SIZES[size]);
                }

                imageCache.set(cacheKey, optimizedUrl);
                return optimizedUrl;
            } else if (error) {
                console.log(`‚ùå Bucket ${bucket}, path ${path} error:`, error.message);
            }
        } catch (bucketError) {
            console.log(`‚ùå Bucket ${bucket}, path ${path} exception:`, bucketError.message);
        }
    }

    // N·∫øu kh√¥ng t√¨m th·∫•y qua signed URL, th·ª≠ getPublicUrl
    for (const { bucket, path } of searchPaths) {
        try {
            console.log(`üîç Trying getPublicUrl for bucket: ${bucket}, path: ${path}`);
            const { data } = supabase.storage
                .from(bucket)
                .getPublicUrl(path);

            if (data?.publicUrl) {
                console.log(`‚úÖ getPublicUrl works: ${data.publicUrl}`);

                // Optimize URL for mobile if needed
                let optimizedUrl = data.publicUrl;
                if (size !== 'full' && MOBILE_SIZES[size]) {
                    optimizedUrl = addImageOptimization(data.publicUrl, MOBILE_SIZES[size]);
                }

                imageCache.set(cacheKey, optimizedUrl);
                return optimizedUrl;
            }
        } catch (getPublicUrlError) {
            console.log(`‚ùå getPublicUrl failed for bucket ${bucket}, path ${path}:`, getPublicUrlError.message);
        }
    }

    // Fallback: th·ª≠ public URL tr·ª±c ti·∫øp
    for (const { bucket, path } of searchPaths) {
        const publicUrl = `${supabaseUrl}/storage/v1/object/public/${bucket}/${path}`;

        try {
            console.log(`üîç Checking public URL: ${publicUrl}`);
            const response = await fetch(publicUrl, {
                method: 'HEAD',
                timeout: 3000
            });

            if (response.ok) {
                console.log(`‚úÖ Public URL works: ${publicUrl}`);

                // Optimize URL for mobile if needed
                let optimizedUrl = publicUrl;
                if (size !== 'full' && MOBILE_SIZES[size]) {
                    optimizedUrl = addImageOptimization(publicUrl, MOBILE_SIZES[size]);
                }

                imageCache.set(cacheKey, optimizedUrl);
                return optimizedUrl;
            }
        } catch (fetchError) {
            console.log(`‚ùå Public URL failed: ${publicUrl}`, fetchError.message);
        }
    }

    console.log('‚ùå No image found, returning null');
    // Tr·∫£ v·ªÅ null ƒë·ªÉ Avatar component c√≥ th·ªÉ fallback v·ªÅ placeholder
    imageCache.set(cacheKey, null);
    console.log('‚ùå All methods failed, using default avatar');
    return '/images/defaultUser.png';
};

// Helper function ƒë·ªÉ th√™m image optimization parameters
const addImageOptimization = (url, sizeConfig) => {
    // N·∫øu URL ƒë√£ c√≥ query parameters, th√™m v√†o
    const separator = url.includes('?') ? '&' : '?';
    return `${url}${separator}width=${sizeConfig.width}&height=${sizeConfig.height}&quality=${sizeConfig.quality}&format=webp`;
};

// Helper function ƒë·ªÉ detect device type
const isMobileDevice = () => {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
};

// Optimized image loading v·ªõi lazy loading
export const loadOptimizedImage = async (imagePath, options = {}) => {
    const {
        size = isMobileDevice() ? 'thumbnail' : 'full',
        lazy = true,
        fallback = null
    } = options;

    try {
        const imageUrl = await getUserImageSrc(imagePath, 'Image', size);

        if (!imageUrl) {
            return fallback;
        }

        // Return image object with optimization info
        return {
            src: imageUrl,
            alt: options.alt || 'Image',
            loading: lazy ? 'lazy' : 'eager',
            width: MOBILE_SIZES[size]?.width,
            height: MOBILE_SIZES[size]?.height,
            style: {
                maxWidth: '100%',
                height: 'auto'
            }
        };
    } catch (error) {
        console.error('Error loading optimized image:', error);
        return fallback;
    }
};

export const getSupabaseFileUrl = (filePath) => {
    if (!filePath) return null;

    if (filePath.startsWith('http')) {
        return filePath;
    }

    return `${supabaseUrl}/storage/v1/object/public/${filePath}`;
};

// Debug function ƒë·ªÉ ki·ªÉm tra Supabase Storage
export const debugSupabaseStorage = async () => {
    console.log('üîç Debugging Supabase Storage...');

    try {
        // Ki·ªÉm tra buckets
        const { data: buckets, error: bucketsError } = await supabase.storage.listBuckets();
        if (bucketsError) {
            console.error('‚ùå Error listing buckets:', bucketsError);
        } else {
            console.log('‚úÖ Available buckets:', buckets?.map(b => b.name) || []);

            // Ki·ªÉm tra files trong m·ªói bucket
            for (const bucket of buckets || []) {
                try {
                    const { data: files, error: filesError } = await supabase.storage
                        .from(bucket.name)
                        .list('', { limit: 10 });

                    if (filesError) {
                        console.log(`‚ùå Error listing files in ${bucket.name}:`, filesError.message);
                    } else {
                        console.log(`‚úÖ Files in ${bucket.name}:`, files?.map(f => f.name) || []);
                    }
                } catch (listError) {
                    console.log(`‚ùå Exception listing files in ${bucket.name}:`, listError.message);
                }
            }
        }

        // Ki·ªÉm tra quy·ªÅn truy c·∫≠p
        const { data: session } = await supabase.auth.getSession();
        console.log('‚úÖ Current session:', session?.session ? 'Authenticated' : 'Not authenticated');

        return { buckets, session };
    } catch (error) {
        console.error('‚ùå Debug error:', error);
        return { error };
    }
};

// Function ƒë·ªÉ t·∫°o bucket profiles n·∫øu ch∆∞a c√≥
export const createProfilesBucket = async () => {
    try {
        console.log('üîß Creating profiles bucket...');

        const { data, error } = await supabase.storage.createBucket('profiles', {
            public: true,
            allowedMimeTypes: ['image/jpeg', 'image/png', 'image/gif', 'image/webp'],
            fileSizeLimit: 5242880 // 5MB
        });

        if (error) {
            console.error('‚ùå Error creating bucket:', error);
            return { success: false, error };
        }

        console.log('‚úÖ Profiles bucket created successfully');
        return { success: true, data };
    } catch (err) {
        console.error('‚ùå Exception creating bucket:', err);
        return { success: false, error: err };
    }
};

// Function ƒë·ªÉ upload avatar
export const uploadAvatar = async (file, userId) => {
    try {
        console.log('üì§ Uploading avatar...');

        // T·∫°o bucket n·∫øu ch∆∞a c√≥
        await createProfilesBucket();

        const fileName = `${userId}.png`;

        const { data, error } = await supabase.storage
            .from('profiles')
            .upload(fileName, file, {
                cacheControl: '3600',
                upsert: true
            });

        if (error) {
            console.error('‚ùå Error uploading avatar:', error);
            return { success: false, error };
        }

        console.log('‚úÖ Avatar uploaded successfully:', data);

        // C·∫≠p nh·∫≠t userData trong database
        const { error: updateError } = await supabase
            .from('users')
            .update({ image: `profiles/${fileName}` })
            .eq('id', userId);

        if (updateError) {
            console.error('‚ùå Error updating user image:', updateError);
        } else {
            console.log('‚úÖ User image updated in database');
        }

        return { success: true, data };
    } catch (err) {
        console.error('‚ùå Exception uploading avatar:', err);
        return { success: false, error: err };
    }
};

// Test function ƒë·ªÉ ki·ªÉm tra bucket upload
export const testUploadBucket = async () => {
    try {
        console.log('üîç Testing upload bucket...');

        // Test list files trong upload bucket
        const { data: files, error: filesError } = await supabase.storage
            .from('upload')
            .list('', { limit: 20 });

        if (filesError) {
            console.log('‚ùå Error listing upload bucket:', filesError);
            return { success: false, error: filesError };
        }

        console.log('üìÅ Files in upload bucket:', files?.map(f => f.name) || []);

        // Test c√°c th∆∞ m·ª•c con
        const folders = ['profiles', 'profile', 'postImages', 'postVideo'];
        for (const folder of folders) {
            try {
                const { data: folderFiles, error: folderError } = await supabase.storage
                    .from('upload')
                    .list(folder, { limit: 10 });

                if (folderError) {
                    console.log(`‚ùå Error listing ${folder}:`, folderError);
                } else {
                    console.log(`üìÅ Files in upload/${folder}:`, folderFiles?.map(f => f.name) || []);
                }
            } catch (err) {
                console.log(`‚ùå Exception checking ${folder}:`, err);
            }
        }

        return { success: true, data: files };
    } catch (error) {
        console.log('‚ùå Error testing upload bucket:', error);
        return { success: false, error };
    }
};

// Test function ƒë·ªÉ load ·∫£nh c·ª• th·ªÉ
export const testLoadImage = async (imagePath) => {
    try {
        console.log(`üîç Testing load image: ${imagePath}`);

        // X·ª≠ l√Ω path ƒë·ªÉ tr√°nh duplicate (gi·ªëng getUserImageSrc)
        let cleanPath = imagePath;
        if (imagePath.startsWith('profiles/')) {
            cleanPath = imagePath.replace('profiles/', '');
        }

        console.log(`üîç Clean path: ${cleanPath}`);

        const searchPaths = [
            { bucket: 'upload', path: `profiles/${cleanPath}` },
            { bucket: 'upload', path: `profile/${cleanPath}` },
            { bucket: 'upload', path: `postImages/${cleanPath}` },
            { bucket: 'upload', path: `postVideo/${cleanPath}` },
            { bucket: 'upload', path: cleanPath }
        ];

        for (const { bucket, path } of searchPaths) {
            try {
                console.log(`üîç Testing: ${bucket}/${path}`);

                const { data, error } = await supabase.storage
                    .from(bucket)
                    .createSignedUrl(path, 3600);

                if (!error && data) {
                    console.log(`‚úÖ Found image at: ${bucket}/${path}`);
                    console.log(`üîó URL: ${data.signedUrl}`);
                    return { success: true, url: data.signedUrl, bucket, path };
                } else {
                    console.log(`‚ùå Not found at: ${bucket}/${path}`, error?.message);
                }
            } catch (err) {
                console.log(`‚ùå Error testing ${bucket}/${path}:`, err);
            }
        }

        console.log(`‚ùå Image not found: ${imagePath}`);
        return { success: false, error: 'Image not found' };
    } catch (error) {
        console.log('‚ùå Error testing load image:', error);
        return { success: false, error };
    }
};
export const debugBuckets = async () => {
    try {
        console.log('üîç Listing all buckets...');
        const { data, error } = await supabase.storage.listBuckets();

        if (error) {
            console.log('‚ùå Error listing buckets:', error);
            return [];
        }

        if (data && data.length > 0) {
            console.log('üì¶ Available buckets:', data.map(b => b.name));

            // Ki·ªÉm tra t·ª´ng bucket
            for (const bucket of data) {
                console.log(`üîç Checking bucket: ${bucket.name}`);
                try {
                    const { data: files, error: filesError } = await supabase.storage
                        .from(bucket.name)
                        .list('', { limit: 10 });

                    if (filesError) {
                        console.log(`‚ùå Error listing files in ${bucket.name}:`, filesError);
                    } else {
                        console.log(`üìÅ Files in ${bucket.name}:`, files?.map(f => f.name) || []);
                    }
                } catch (err) {
                    console.log(`‚ùå Exception checking ${bucket.name}:`, err);
                }
            }

            return data.map(b => b.name);
        } else {
            console.log('üì¶ No buckets found or empty response');
            return [];
        }
    } catch (error) {
        console.log('‚ùå Error listing buckets:', error);
        return [];
    }
};